const nodemailer = require("nodemailer");
const fs = require("fs").promises;
const path = require("path");

// Use centralized logging system
const { createPluginLogger } = require("../../utils/logger");
const logger = createPluginLogger("web-performance");

// Email Service Functions
const createTransporter = () => {
  const requiredEnvVars = [
    "EMAIL_HOST",
    "EMAIL_PORT",
    "EMAIL_USER",
    "EMAIL_PASSWORD",
    "EMAIL_FROM",
  ];

  if (requiredEnvVars.some((v) => !process.env[v])) {
    throw new Error("Missing required email configuration");
  }

  const port = parseInt(process.env.EMAIL_PORT, 10);
  if (isNaN(port)) {
    throw new Error("EMAIL_PORT must be a valid number");
  }

  const secure = port === 465;

  return nodemailer.createTransporter({
    host: process.env.EMAIL_HOST,
    port: port,
    secure: secure,
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASSWORD,
    },
    tls: {
      rejectUnauthorized: process.env.NODE_ENV === "production",
    },
  });
};

const sendEmail = async (mailOptions) => {
  try {
    const transporter = createTransporter();
    const result = await transporter.sendMail(mailOptions);
    logger.utils.info("Email sent successfully", {
      to: mailOptions.to,
      subject: mailOptions.subject,
      messageId: result.messageId,
    });
    return result;
  } catch (error) {
    logger.utils.error("Error sending email", {
      error: error.message,
      errorStack: error.stack,
      to: mailOptions.to,
      subject: mailOptions.subject,
    });
    throw error;
  }
};

// Performance Alert Email Functions
const sendPerformanceAlertEmail = async (alertInfo) => {
  const {
    to,
    alertType,
    severity,
    message,
    metrics,
    recommendations,
    timestamp,
  } = alertInfo;

  const severityColors = {
    info: "#2196F3",
    warning: "#FF9800",
    error: "#F44336",
    critical: "#D32F2F",
  };

  const color = severityColors[severity] || "#2196F3";

  return sendEmail({
    to,
    from: process.env.EMAIL_FROM,
    subject: `[Performance Alert - ${severity.toUpperCase()}] ${alertType}`,
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background: ${color}; color: white; padding: 20px; text-align: center;">
          <h1 style="margin: 0;">Performance Alert</h1>
          <p style="margin: 10px 0 0 0; font-size: 18px;">${severity.toUpperCase()}</p>
        </div>
        
        <div style="padding: 20px; background: #f5f5f5;">
          <h2 style="color: #333; margin-top: 0;">Alert Details</h2>
          <p><strong>Type:</strong> ${alertType}</p>
          <p><strong>Time:</strong> ${new Date(timestamp).toUTCString()}</p>
          <p><strong>Message:</strong> ${message}</p>
        </div>

        ${
          metrics
            ? `
        <div style="padding: 20px;">
          <h3 style="color: #333;">Performance Metrics</h3>
          <table style="width: 100%; border-collapse: collapse;">
            ${Object.entries(metrics)
              .map(
                ([key, value]) => `
              <tr style="border-bottom: 1px solid #ddd;">
                <td style="padding: 8px; font-weight: bold;">${key}</td>
                <td style="padding: 8px;">${value}</td>
              </tr>
            `
              )
              .join("")}
          </table>
        </div>
        `
            : ""
        }

        ${
          recommendations
            ? `
        <div style="padding: 20px; background: #e8f5e8;">
          <h3 style="color: #2e7d32; margin-top: 0;">Recommendations</h3>
          <ul style="margin: 10px 0;">
            ${recommendations
              .map((rec) => `<li style="margin: 5px 0;">${rec}</li>`)
              .join("")}
          </ul>
        </div>
        `
            : ""
        }

        <div style="padding: 20px; background: #f0f0f0; text-align: center; font-size: 14px; color: #666;">
          <p>This alert was automatically generated by your Web Performance Optimization system.</p>
          <p>For assistance, please contact your system administrator.</p>
        </div>
      </div>
    `,
  });
};

const sendOptimizationResultEmail = async (resultInfo) => {
  const { to, operationType, results, summary, timestamp } = resultInfo;

  return sendEmail({
    to,
    from: process.env.EMAIL_FROM,
    subject: `[Optimization Complete] ${operationType}`,
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background: #4CAF50; color: white; padding: 20px; text-align: center;">
          <h1 style="margin: 0;">Optimization Complete</h1>
          <p style="margin: 10px 0 0 0; font-size: 18px;">${operationType}</p>
        </div>
        
        <div style="padding: 20px;">
          <h2 style="color: #333; margin-top: 0;">Results Summary</h2>
          <p><strong>Completed:</strong> ${new Date(
            timestamp
          ).toUTCString()}</p>
          
          <div style="background: #f0f8ff; padding: 15px; border-radius: 5px; margin: 15px 0;">
            <h3 style="margin-top: 0; color: #1976D2;">Performance Gains</h3>
            <p><strong>Files Processed:</strong> ${summary.filesProcessed}</p>
            <p><strong>Total Size Saved:</strong> ${formatFileSize(
              summary.totalSizeSaved
            )}</p>
            <p><strong>Average Compression:</strong> ${
              summary.averageCompression
            }%</p>
            <p><strong>Processing Time:</strong> ${summary.processingTime}s</p>
          </div>

          ${
            results.length > 0
              ? `
          <h3 style="color: #333;">Detailed Results</h3>
          <table style="width: 100%; border-collapse: collapse;">
            <tr style="background: #f5f5f5;">
              <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">File</th>
              <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Original</th>
              <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Optimized</th>
              <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Saved</th>
            </tr>
            ${results
              .slice(0, 10)
              .map(
                (result) => `
              <tr style="border-bottom: 1px solid #ddd;">
                <td style="padding: 8px;">${path.basename(result.filePath)}</td>
                <td style="padding: 8px;">${formatFileSize(
                  result.originalSize
                )}</td>
                <td style="padding: 8px;">${formatFileSize(
                  result.optimizedSize
                )}</td>
                <td style="padding: 8px; color: #4CAF50;">${formatFileSize(
                  result.savings
                )}</td>
              </tr>
            `
              )
              .join("")}
            ${
              results.length > 10
                ? `
              <tr>
                <td colspan="4" style="padding: 8px; text-align: center; font-style: italic;">
                  ... and ${results.length - 10} more files
                </td>
              </tr>
            `
                : ""
            }
          </table>
          `
              : ""
          }
        </div>

        <div style="padding: 20px; background: #f0f0f0; text-align: center; font-size: 14px; color: #666;">
          <p>This report was automatically generated by your Web Performance Optimization system.</p>
        </div>
      </div>
    `,
  });
};

const sendPerformanceReportEmail = async (reportInfo) => {
  const {
    to,
    reportType,
    timeRange,
    metrics,
    trends,
    recommendations,
    timestamp,
  } = reportInfo;

  return sendEmail({
    to,
    from: process.env.EMAIL_FROM,
    subject: `[Performance Report] ${reportType} - ${timeRange}`,
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 700px; margin: 0 auto;">
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; text-align: center;">
          <h1 style="margin: 0; font-size: 28px;">Performance Report</h1>
          <p style="margin: 10px 0 0 0; font-size: 16px; opacity: 0.9;">${reportType} | ${timeRange}</p>
          <p style="margin: 5px 0 0 0; font-size: 14px; opacity: 0.8;">${new Date(
            timestamp
          ).toLocaleDateString()}</p>
        </div>
        
        <div style="padding: 25px;">
          <h2 style="color: #333; margin-top: 0; border-bottom: 2px solid #667eea; padding-bottom: 10px;">Executive Summary</h2>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0;">
            <div style="background: #f8f9ff; padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #667eea;">
              <h4 style="margin: 0; color: #667eea;">Total Optimizations</h4>
              <p style="margin: 5px 0 0 0; font-size: 24px; font-weight: bold; color: #333;">${
                metrics.totalOptimizations
              }</p>
            </div>
            <div style="background: #f0f8f0; padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #4CAF50;">
              <h4 style="margin: 0; color: #4CAF50;">Size Saved</h4>
              <p style="margin: 5px 0 0 0; font-size: 24px; font-weight: bold; color: #333;">${formatFileSize(
                metrics.totalSizeSaved
              )}</p>
            </div>
            <div style="background: #fff8f0; padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #FF9800;">
              <h4 style="margin: 0; color: #FF9800;">Avg Response Time</h4>
              <p style="margin: 5px 0 0 0; font-size: 24px; font-weight: bold; color: #333;">${
                metrics.avgResponseTime
              }ms</p>
            </div>
            <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #2196F3;">
              <h4 style="margin: 0; color: #2196F3;">Cache Hit Rate</h4>
              <p style="margin: 5px 0 0 0; font-size: 24px; font-weight: bold; color: #333;">${
                metrics.avgCacheHitRate
              }%</p>
            </div>
          </div>

          ${
            trends && trends.length > 0
              ? `
          <h3 style="color: #333; margin-top: 30px;">Performance Trends</h3>
          <div style="background: #fafafa; padding: 15px; border-radius: 5px;">
            ${trends
              .map(
                (trend) => `
              <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 3px;">
                <strong>${trend.metric}:</strong> ${
                  trend.change > 0 ? "ðŸ“ˆ" : "ðŸ“‰"
                } ${Math.abs(trend.change)}% ${
                  trend.change > 0 ? "increase" : "decrease"
                }
                <span style="color: ${
                  trend.change > 0 ? "#4CAF50" : "#F44336"
                }; font-size: 12px; margin-left: 10px;">${trend.period}</span>
              </div>
            `
              )
              .join("")}
          </div>
          `
              : ""
          }

          ${
            recommendations && recommendations.length > 0
              ? `
          <h3 style="color: #333; margin-top: 30px;">Optimization Recommendations</h3>
          <div style="background: #e8f5e8; padding: 15px; border-radius: 5px; border-left: 4px solid #4CAF50;">
            <ul style="margin: 0; padding-left: 20px;">
              ${recommendations
                .map(
                  (rec) =>
                    `<li style="margin: 8px 0; color: #2e7d32;">${rec}</li>`
                )
                .join("")}
            </ul>
          </div>
          `
              : ""
          }
        </div>

        <div style="padding: 20px; background: #f5f5f5; text-align: center; font-size: 14px; color: #666;">
          <p>This automated report helps you track and improve your website's performance.</p>
          <p>For detailed analysis, visit your Web Performance dashboard.</p>
        </div>
      </div>
    `,
  });
};

// Utility Functions
const formatFileSize = (bytes) => {
  if (!bytes || bytes === 0) return "0 B";
  const k = 1024;
  const sizes = ["B", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
};

const calculateMetricsSummary = (chartData) => {
  if (chartData.length === 0) {
    return {
      totalOptimizations: 0,
      totalSizeSaved: 0,
      avgCacheHitRate: 0,
      avgResponseTime: 0,
    };
  }

  const totals = chartData.reduce(
    (acc, day) => {
      acc.optimizations +=
        day.optimization.cssMinified +
        day.optimization.jsMinified +
        day.optimization.imagesOptimized;
      acc.sizeSaved += day.optimization.totalSizeSaved;
      acc.cacheHits += day.caching.cacheHits;
      acc.cacheMisses += day.caching.cacheMisses;
      acc.responseTimeSum += day.caching.avgResponseTime;
      acc.responseTimeCount += day.caching.avgResponseTime > 0 ? 1 : 0;
      return acc;
    },
    {
      optimizations: 0,
      sizeSaved: 0,
      cacheHits: 0,
      cacheMisses: 0,
      responseTimeSum: 0,
      responseTimeCount: 0,
    }
  );

  const totalRequests = totals.cacheHits + totals.cacheMisses;
  const cacheHitRate =
    totalRequests > 0 ? (totals.cacheHits / totalRequests) * 100 : 0;
  const avgResponseTime =
    totals.responseTimeCount > 0
      ? totals.responseTimeSum / totals.responseTimeCount
      : 0;

  return {
    totalOptimizations: totals.optimizations,
    totalSizeSaved: totals.sizeSaved,
    avgCacheHitRate: Math.round(cacheHitRate * 100) / 100,
    avgResponseTime: Math.round(avgResponseTime * 100) / 100,
  };
};

// Data Cleanup and Retention Functions
const cleanupExpiredMetrics = async (retentionDays = 90) => {
  const { PerformanceMetrics } = require("./models");

  try {
    const cutoffDate = new Date(
      Date.now() - retentionDays * 24 * 60 * 60 * 1000
    );
    const result = await PerformanceMetrics.deleteMany({
      date: { $lt: cutoffDate },
    });

    if (result.deletedCount > 0) {
      logger.utils.info("Deleted expired performance metrics", {
        deletedCount: result.deletedCount,
        retentionDays,
      });
    }

    return result.deletedCount;
  } catch (error) {
    logger.utils.error("Failed to clean up expired metrics", {
      error: error.message,
      errorStack: error.stack,
    });
    return 0;
  }
};

const cleanupExpiredLogs = async (retentionDays = 30) => {
  const { PerformanceLogs } = require("./models");

  try {
    const cutoffDate = new Date(
      Date.now() - retentionDays * 24 * 60 * 60 * 1000
    );
    const result = await PerformanceLogs.deleteMany({
      timestamp: { $lt: cutoffDate },
    });

    if (result.deletedCount > 0) {
      logger.utils.info("Deleted expired performance logs", {
        deletedCount: result.deletedCount,
        retentionDays,
      });
    }

    return result.deletedCount;
  } catch (error) {
    logger.utils.error("Failed to clean up expired logs", {
      error: error.message,
      errorStack: error.stack,
    });
    return 0;
  }
};

const cleanupProcessingQueue = async (retentionDays = 7) => {
  const { ProcessingQueue } = require("./models");

  try {
    // Clean up completed/failed tasks older than retention period
    const cutoffDate = new Date(
      Date.now() - retentionDays * 24 * 60 * 60 * 1000
    );
    const result = await ProcessingQueue.deleteMany({
      status: { $in: ["completed", "failed", "cancelled"] },
      updatedAt: { $lt: cutoffDate },
    });

    if (result.deletedCount > 0) {
      logger.utils.info("Deleted old processing queue items", {
        deletedCount: result.deletedCount,
        retentionDays,
      });
    }

    return result.deletedCount;
  } catch (error) {
    logger.utils.error("Failed to clean up processing queue", {
      error: error.message,
      errorStack: error.stack,
    });
    return 0;
  }
};

const cleanupTempFiles = async () => {
  try {
    const tempDir = path.join(__dirname, "../../../uploads/temp/performance");
    let deletedCount = 0;

    try {
      const files = await fs.readdir(tempDir);
      const cutoffTime = Date.now() - 24 * 60 * 60 * 1000; // 24 hours ago

      for (const file of files) {
        const filePath = path.join(tempDir, file);
        try {
          const stats = await fs.stat(filePath);
          if (stats.mtime.getTime() < cutoffTime) {
            await fs.unlink(filePath);
            deletedCount++;
          }
        } catch (fileError) {
          // File might have been deleted already, continue
        }
      }
    } catch (dirError) {
      // Directory might not exist, that's ok
    }

    if (deletedCount > 0) {
      logger.utils.info("Deleted temporary files", {
        deletedCount,
      });
    }

    return deletedCount;
  } catch (error) {
    logger.utils.error("Failed to clean up temporary files", {
      error: error.message,
      errorStack: error.stack,
    });
    return 0;
  }
};

const enforceMaxLogEntries = async (maxEntries = 50000) => {
  const { PerformanceLogs } = require("./models");

  try {
    const totalCount = await PerformanceLogs.countDocuments();

    if (totalCount > maxEntries) {
      const excessCount = totalCount - maxEntries;

      const oldestLogs = await PerformanceLogs.find()
        .sort({ timestamp: 1 })
        .limit(excessCount)
        .select("_id");

      const idsToDelete = oldestLogs.map((log) => log._id);
      const result = await PerformanceLogs.deleteMany({
        _id: { $in: idsToDelete },
      });

      logger.utils.info("Deleted excess performance logs", {
        deletedCount: result.deletedCount,
        maxEntries,
      });
      return result.deletedCount;
    }

    return 0;
  } catch (error) {
    logger.utils.error("Failed to enforce max log entries", {
      error: error.message,
      errorStack: error.stack,
    });
    return 0;
  }
};

const performDataRetentionCleanup = async (force = false, range = "all") => {
  try {
    logger.utils.info("Starting performance data retention cleanup", {
      mode: force ? "manual" : "automatic",
      range: force ? range : "automatic",
    });

    let totalDeleted = 0;
    const results = {
      metrics: 0,
      logs: 0,
      queue: 0,
      tempFiles: 0,
      alerts: 0,
    };

    if (force) {
      // Manual cleanup with specific ranges
      const rangeMap = {
        last_hour: 1 / 24,
        last_day: 1,
        last_week: 7,
        last_month: 30,
        last_3_months: 90,
        last_6_months: 180,
        last_year: 365,
        all: 0,
      };

      const days = rangeMap[range] || 30;

      if (range === "all" || days > 0) {
        results.metrics = await cleanupExpiredMetrics(days);
        results.logs = await cleanupExpiredLogs(days);
        results.queue = await cleanupProcessingQueue(Math.min(days, 7));
      }
    } else {
      // Automatic cleanup using settings
      const { WebPerformanceSettings } = require("./models");
      const { STATIC_CONFIG } = require("./config");

      let settings = await WebPerformanceSettings.findOne({
        settingsId: STATIC_CONFIG.database.defaultSettingsId,
      });

      const metricsRetention =
        settings?.dataRetention?.metricsRetentionDays || 90;
      const logsRetention = settings?.dataRetention?.logsRetentionDays || 30;
      const queueRetention = settings?.dataRetention?.queueRetentionDays || 7;
      const maxLogEntries = settings?.dataRetention?.maxLogEntries || 50000;

      results.metrics = await cleanupExpiredMetrics(metricsRetention);
      results.logs = await cleanupExpiredLogs(logsRetention);
      results.queue = await cleanupProcessingQueue(queueRetention);

      // Enforce max log entries
      const excessLogs = await enforceMaxLogEntries(maxLogEntries);
      results.logs += excessLogs;
    }

    // Always clean temp files
    results.tempFiles = await cleanupTempFiles();

    totalDeleted = Object.values(results).reduce(
      (sum, count) => sum + count,
      0
    );

    logger.utils.info("Performance data cleanup completed", {
      totalDeleted,
      results,
      forced: force,
      range: force ? range : "automatic",
    });

    return {
      ...results,
      totalDeleted,
      forced: force,
      range: force ? range : "automatic",
    };
  } catch (error) {
    logger.utils.error("Performance data retention cleanup failed", {
      error: error.message,
      errorStack: error.stack,
    });
    return {
      metrics: 0,
      logs: 0,
      queue: 0,
      tempFiles: 0,
      alerts: 0,
      totalDeleted: 0,
      error: error.message,
    };
  }
};

// Background Job Management
let cleanupInterval = null;
let processingInterval = null;

const startDataRetentionJobs = () => {
  if (cleanupInterval) {
    logger.utils.info("Data retention jobs already running");
    return;
  }

  logger.utils.info("Starting performance data retention jobs");

  // Run cleanup immediately on startup
  setImmediate(() => {
    performDataRetentionCleanup();
  });

  // Schedule cleanup every 24 hours
  cleanupInterval = setInterval(() => {
    performDataRetentionCleanup();
  }, 24 * 60 * 60 * 1000);

  logger.utils.info("Data retention jobs scheduled", {
    interval: "24 hours",
  });
};

const stopDataRetentionJobs = () => {
  if (cleanupInterval) {
    clearInterval(cleanupInterval);
    cleanupInterval = null;
    logger.utils.info("Data retention jobs stopped");
  }
};

const startBackgroundProcessing = () => {
  if (processingInterval) {
    logger.utils.info("Background processing already running");
    return;
  }

  logger.utils.info("Starting background optimization processing");

  // Start processing queue immediately
  setImmediate(() => {
    processOptimizationQueue();
  });

  // Schedule processing every 30 seconds
  processingInterval = setInterval(() => {
    processOptimizationQueue();
  }, 30 * 1000);

  logger.utils.info("Background processing scheduled", {
    interval: "30 seconds",
  });
};

const stopBackgroundProcessing = () => {
  if (processingInterval) {
    clearInterval(processingInterval);
    processingInterval = null;
    logger.utils.info("Background processing stopped");
  }
};

const processOptimizationQueue = async () => {
  try {
    const { ProcessingQueue } = require("./models");

    // Get pending tasks
    const pendingTasks = await ProcessingQueue.find({
      status: "pending",
    })
      .sort({ priority: -1, createdAt: 1 })
      .limit(5); // Process up to 5 tasks at once

    if (pendingTasks.length === 0) {
      return;
    }

    logger.utils.info("Processing optimization queue", {
      taskCount: pendingTasks.length,
    });

    // Process tasks concurrently
    const promises = pendingTasks.map((task) => processSingleTask(task));
    await Promise.allSettled(promises);
  } catch (error) {
    logger.utils.error("Error processing optimization queue", {
      error: error.message,
      errorStack: error.stack,
    });
  }
};

const processSingleTask = async (task) => {
  const { ProcessingQueue } = require("./models");

  try {
    // Update task status to processing
    await ProcessingQueue.findByIdAndUpdate(task._id, {
      status: "processing",
      updatedAt: new Date(),
    });

    logger.utils.info("Processing optimization task", {
      taskId: task._id,
      type: task.taskType,
      filePath: task.filePath,
    });

    // Simulate processing based on task type
    let result;
    switch (task.taskType) {
      case "minify_css":
        result = await processMinifyCSS(task);
        break;
      case "minify_js":
        result = await processMinifyJS(task);
        break;
      case "optimize_image":
        result = await processOptimizeImage(task);
        break;
      case "upload_to_r2":
        result = await processUploadToR2(task);
        break;
      default:
        throw new Error(`Unknown task type: ${task.taskType}`);
    }

    // Update task with success
    await ProcessingQueue.findByIdAndUpdate(task._id, {
      status: "completed",
      result: result,
      completedAt: new Date(),
      updatedAt: new Date(),
    });

    logger.utils.info("Optimization task completed", {
      taskId: task._id,
      result,
    });
  } catch (error) {
    logger.utils.error("Optimization task failed", {
      taskId: task._id,
      error: error.message,
      errorStack: error.stack,
    });

    // Update task with failure
    await ProcessingQueue.findByIdAndUpdate(task._id, {
      status: "failed",
      error: error.message,
      attempts: task.attempts + 1,
      updatedAt: new Date(),
    });
  }
};

// Placeholder processing functions (to be implemented)
const processMinifyCSS = async (task) => {
  // Placeholder - implement CSS minification
  return {
    originalSize: 10000,
    optimizedSize: 7000,
    savings: 3000,
    processingTime: 150,
  };
};

const processMinifyJS = async (task) => {
  // Placeholder - implement JS minification
  return {
    originalSize: 15000,
    optimizedSize: 9000,
    savings: 6000,
    processingTime: 200,
  };
};

const processOptimizeImage = async (task) => {
  // Placeholder - implement image optimization
  return {
    originalSize: 500000,
    optimizedSize: 300000,
    savings: 200000,
    processingTime: 800,
  };
};

const processUploadToR2 = async (task) => {
  // Placeholder - implement R2 upload
  return {
    originalSize: 100000,
    optimizedSize: 100000,
    savings: 0,
    processingTime: 300,
    uploadUrl: "https://cdn.example.com/file.jpg",
  };
};

module.exports = {
  // Email functions
  sendEmail,
  sendPerformanceAlertEmail,
  sendOptimizationResultEmail,
  sendPerformanceReportEmail,

  // Utility functions
  formatFileSize,
  calculateMetricsSummary,

  // Cleanup functions
  cleanupExpiredMetrics,
  cleanupExpiredLogs,
  cleanupProcessingQueue,
  cleanupTempFiles,
  performDataRetentionCleanup,

  // Background job management
  startDataRetentionJobs,
  stopDataRetentionJobs,
  startBackgroundProcessing,
  stopBackgroundProcessing,
  processOptimizationQueue,
};
