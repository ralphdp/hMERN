const nodemailer = require("nodemailer");
const { FirewallRule } = require("./models");

// Use centralized logging system
const { createPluginLogger } = require("../../utils/logger");
const logger = createPluginLogger("firewall");

const createTransporter = () => {
  const requiredEnvVars = [
    "EMAIL_HOST",
    "EMAIL_PORT",
    "EMAIL_USER",
    "EMAIL_PASSWORD",
    "EMAIL_FROM",
  ];
  if (requiredEnvVars.some((v) => !process.env[v])) {
    throw new Error("Missing required email configuration");
  }

  // Parse port as number
  const port = parseInt(process.env.EMAIL_PORT, 10);
  if (isNaN(port)) {
    throw new Error("EMAIL_PORT must be a valid number");
  }

  // Determine if we should use secure connection
  const secure = port === 465;

  return nodemailer.createTransport({
    host: process.env.EMAIL_HOST,
    port: port,
    secure: secure,
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASSWORD,
    },
    // Add TLS options for better security
    tls: {
      rejectUnauthorized: process.env.NODE_ENV === "production",
    },
  });
};

const sendEmail = async (mailOptions) => {
  try {
    const transporter = createTransporter();
    return await transporter.sendMail(mailOptions);
  } catch (error) {
    logger.utils.error("Error sending email", {
      error: error.message,
      errorStack: error.stack,
    });
  }
};

const sendFirewallTestResultEmail = async (testInfo) => {
  const { to, title, message, ip } = testInfo;
  return sendEmail({
    to,
    from: process.env.EMAIL_FROM,
    subject: `[Firewall Test] ${title}`,
    html: `
      <h1>Firewall Test Result</h1>
      <p>${message}</p>
      ${ip ? `<p><strong>Detected IP:</strong> ${ip}</p>` : ""}
      <p>This test was performed to verify your firewall configuration is working correctly.</p>
      <p>If you did not initiate this test, please contact your system administrator.</p>
    `,
  });
};

const sendFirewallAlertEmail = async (alertInfo) => {
  const { to, ip, rule, reason, url, userAgent, timestamp } = alertInfo;
  return sendEmail({
    to,
    from: process.env.EMAIL_FROM,
    subject: `[Firewall Alert] ${reason}`,
    html: `
      <h1>Firewall Security Alert</h1>
      <p>A security threat has been detected and blocked by your firewall system.</p>
      <h2>Alert Details:</h2>
      <p><strong>Time:</strong> ${new Date(timestamp).toUTCString()}</p>
      <p><strong>Reason:</strong> ${reason}</p>
      <p><strong>Rule:</strong> ${rule || "N/A"}</p>
      <p><strong>IP Address:</strong> ${ip}</p>
      <p><strong>URL:</strong> ${url}</p>
      <p><strong>User Agent:</strong> ${userAgent}</p>
      <p>This alert was automatically generated by your firewall monitoring system.</p>
      <p>If you believe this is a false positive, please review your firewall rules and settings.</p>
    `,
  });
};

const addCommonFirewallRules = async (invalidateRuleCache) => {
  try {
    const commonRules = [
      // XSS Protection
      {
        name: "Block XSS Attacks",
        type: "suspicious_pattern",
        value: "<script[^>]*>.*?</script>",
        action: "block",
        priority: 10,
        enabled: true,
        source: "common_rules",
        description: "Blocks basic XSS attempts with script tags",
      },
      {
        name: "Block JavaScript Events",
        type: "suspicious_pattern",
        value: "on(load|click|mouseover|error)\\s*=",
        action: "block",
        priority: 10,
        enabled: true,
        source: "common_rules",
        description: "Blocks JavaScript event handlers in URLs",
      },

      // SQL Injection Protection
      {
        name: "Block SQL Injection - UNION",
        type: "suspicious_pattern",
        value: "(union|UNION).*(select|SELECT)",
        action: "block",
        priority: 10,
        enabled: true,
        source: "common_rules",
        description: "Blocks SQL UNION injection attempts",
      },
      {
        name: "Block SQL Injection - OR 1=1",
        type: "suspicious_pattern",
        value: "(or|OR)\\s+(1=1|'1'='1')",
        action: "block",
        priority: 10,
        enabled: true,
        source: "common_rules",
        description: "Blocks common SQL injection patterns",
      },

      // Command Injection Protection
      {
        name: "Block Command Injection",
        type: "suspicious_pattern",
        value: "(;|\\||&|`|\\$\\(|\\$\\{).*(cat|ls|pwd|whoami|id|uname)",
        action: "block",
        priority: 10,
        enabled: true,
        source: "common_rules",
        description: "Blocks command injection attempts",
      },

      // Path Traversal Protection
      {
        name: "Block Path Traversal",
        type: "suspicious_pattern",
        value: "(\\.\\./|\\.\\.\\\\/|%2e%2e%2f|%2e%2e\\\\)",
        action: "block",
        priority: 10,
        enabled: true,
        source: "common_rules",
        description: "Blocks directory traversal attacks",
      },

      // Bot Protection
      {
        name: "Block Bad Bots",
        type: "suspicious_pattern",
        value:
          "(bot|crawler|spider|scraper|scanner|curl|wget|python|perl|php|java)",
        action: "block",
        priority: 20,
        enabled: true,
        source: "common_rules",
        description: "Blocks common bot user agents",
      },

      // Malicious IPs (examples)
      {
        name: "Block Tor Exit Nodes",
        type: "ip_block",
        value: "192.42.116.0/24",
        action: "block",
        priority: 5,
        enabled: true,
        source: "common_rules",
        description: "Blocks known Tor exit node range",
      },

      // Suspicious File Extensions
      {
        name: "Block Malicious Files",
        type: "suspicious_pattern",
        value: "\\.(php|asp|aspx|jsp|cgi|pl|sh|exe|bat|cmd)$",
        action: "block",
        priority: 15,
        enabled: true,
        source: "common_rules",
        description: "Blocks requests for potentially malicious file types",
      },

      // Rate Limiting for Common Endpoints
      {
        name: "Rate Limit Login Attempts",
        type: "rate_limit",
        value: "/login",
        action: "rate_limit",
        priority: 5,
        enabled: true,
        source: "common_rules",
        description: "Rate limits login attempts to prevent brute force",
      },
      {
        name: "Rate Limit API Calls",
        type: "rate_limit",
        value: "/api/",
        action: "rate_limit",
        priority: 10,
        enabled: true,
        source: "common_rules",
        description: "Rate limits API endpoint access",
      },
    ];

    logger.utils.info("Adding common firewall rules", {
      ruleCount: commonRules.length,
    });

    // Remove existing common rules first
    const deleteResult = await FirewallRule.deleteMany({
      source: "common_rules",
    });
    logger.utils.info("Deleted existing common rules", {
      deletedCount: deleteResult.deletedCount,
    });

    // Insert new common rules
    const result = await FirewallRule.insertMany(commonRules, {
      ordered: false,
    });
    logger.utils.info("Successfully added common rules", {
      addedCount: result.length,
    });

    // Invalidate cache
    if (invalidateRuleCache) {
      invalidateRuleCache();
      logger.utils.debug("Rule cache invalidated");
    }

    return {
      success: true,
      added: result.length,
      deleted: deleteResult.deletedCount,
      message: `Successfully added ${result.length} common firewall rules`,
    };
  } catch (error) {
    logger.utils.error("Error adding common firewall rules", {
      error: error.message,
      errorStack: error.stack,
    });
    return {
      success: false,
      error: error.message,
      added: 0,
    };
  }
};

// Data Retention Cleanup Functions
const cleanupExpiredLogs = async (retentionDays = 30) => {
  const { FirewallLog } = require("./models");

  try {
    const cutoffDate = new Date(
      Date.now() - retentionDays * 24 * 60 * 60 * 1000
    );
    const result = await FirewallLog.deleteMany({
      timestamp: { $lt: cutoffDate },
    });

    if (result.deletedCount > 0) {
      logger.utils.info("Deleted expired logs", {
        deletedCount: result.deletedCount,
        retentionDays,
      });
    }

    return result.deletedCount;
  } catch (error) {
    logger.utils.error("Failed to clean up expired logs", {
      error: error.message,
      errorStack: error.stack,
    });
    return 0;
  }
};

const enforceMaxLogEntries = async (maxEntries = 10000) => {
  const { FirewallLog } = require("./models");

  try {
    const totalCount = await FirewallLog.countDocuments();

    if (totalCount > maxEntries) {
      const excessCount = totalCount - maxEntries;

      // Delete oldest logs beyond the limit
      const oldestLogs = await FirewallLog.find()
        .sort({ timestamp: 1 })
        .limit(excessCount)
        .select("_id");

      const idsToDelete = oldestLogs.map((log) => log._id);
      const result = await FirewallLog.deleteMany({
        _id: { $in: idsToDelete },
      });

      logger.utils.info("Deleted excess logs", {
        deletedCount: result.deletedCount,
        maxEntries,
      });
      return result.deletedCount;
    }

    return 0;
  } catch (error) {
    logger.utils.error("Failed to enforce max log entries", {
      error: error.message,
      errorStack: error.stack,
    });
    return 0;
  }
};

const performDataRetentionCleanup = async (force = false, range = "all") => {
  try {
    logger.utils.info("Starting data retention cleanup", {
      mode: force ? "manual" : "automatic",
      range: force ? range : "automatic",
    });

    const { FirewallLog } = require("./models");

    if (force) {
      // Manual cleanup with different range options
      logger.utils.info("Manual cleanup with specific range", { range });

      let deleteFilter = {};
      let deletedCount = 0;
      let rangeDescription = "";

      switch (range) {
        case "all":
          // Delete ALL logs
          deleteFilter = {};
          rangeDescription = "all logs";
          break;

        case "last7days":
          // Delete logs from the last 7 days
          const last7Days = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
          deleteFilter = { timestamp: { $gte: last7Days } };
          rangeDescription = "logs from the last 7 days";
          break;

        case "last30days":
          // Delete logs from the last 30 days
          const last30Days = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
          deleteFilter = { timestamp: { $gte: last30Days } };
          rangeDescription = "logs from the last 30 days";
          break;

        case "last90days":
          // Delete logs from the last 90 days
          const last90Days = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
          deleteFilter = { timestamp: { $gte: last90Days } };
          rangeDescription = "logs from the last 90 days";
          break;

        case "older6months":
          // Delete logs older than 6 months
          const sixMonthsAgo = new Date(
            Date.now() - 6 * 30 * 24 * 60 * 60 * 1000
          );
          deleteFilter = { timestamp: { $lt: sixMonthsAgo } };
          rangeDescription = "logs older than 6 months";
          break;

        case "older1year":
          // Delete logs older than 1 year
          const oneYearAgo = new Date(Date.now() - 365 * 24 * 60 * 60 * 1000);
          deleteFilter = { timestamp: { $lt: oneYearAgo } };
          rangeDescription = "logs older than 1 year";
          break;

        default:
          // Default to all logs
          deleteFilter = {};
          rangeDescription = "all logs";
      }

      const result = await FirewallLog.deleteMany(deleteFilter);
      deletedCount = result.deletedCount;

      logger.utils.info("Manual cleanup completed", {
        deletedCount,
        rangeDescription,
      });

      return {
        deletedByAge: 0,
        deletedByCount: deletedCount,
        totalDeleted: deletedCount,
        forced: true,
        range: range,
        rangeDescription: rangeDescription,
      };
    }

    // Automatic cleanup - use retention settings
    const { FirewallConfig } = require("./models");
    const { STATIC_CONFIG } = require("./config");

    let config = await FirewallConfig.findOne({
      pluginId: STATIC_CONFIG.pluginId,
    });

    // Use default values if no config found
    const retentionDays = config?.thresholds?.logRetentionDays || 30;
    const maxEntries = config?.thresholds?.maxLogEntries || 10000;

    logger.utils.info("Using retention settings", {
      retentionDays,
      maxEntries,
    });

    // Perform cleanup operations
    const deletedByAge = await cleanupExpiredLogs(retentionDays);
    const deletedByCount = await enforceMaxLogEntries(maxEntries);

    const totalDeleted = deletedByAge + deletedByCount;

    if (totalDeleted > 0) {
      logger.utils.info("Cleanup completed", {
        totalDeleted,
        deletedByAge,
        deletedByCount,
      });
    } else {
      logger.utils.info("Cleanup completed - no cleanup needed");
    }

    return { deletedByAge, deletedByCount, totalDeleted };
  } catch (error) {
    logger.utils.error("Data retention cleanup failed", {
      error: error.message,
      errorStack: error.stack,
    });
    return {
      deletedByAge: 0,
      deletedByCount: 0,
      totalDeleted: 0,
      error: error.message,
    };
  }
};

// Schedule cleanup job to run daily
let cleanupInterval = null;

const startDataRetentionJobs = () => {
  if (cleanupInterval) {
    logger.utils.info("Data retention jobs already running");
    return;
  }

  logger.utils.info("Starting data retention jobs");

  // Run cleanup immediately on startup
  setImmediate(() => {
    performDataRetentionCleanup();
  });

  // Schedule cleanup every 24 hours
  cleanupInterval = setInterval(() => {
    performDataRetentionCleanup();
  }, 24 * 60 * 60 * 1000); // 24 hours

  logger.utils.info("Data retention jobs scheduled", {
    interval: "24 hours",
  });
};

const stopDataRetentionJobs = () => {
  if (cleanupInterval) {
    clearInterval(cleanupInterval);
    cleanupInterval = null;
    logger.utils.info("Data retention jobs stopped");
  }
};

module.exports = {
  sendFirewallTestResultEmail,
  sendFirewallAlertEmail,
  addCommonFirewallRules,
  cleanupExpiredLogs,
  enforceMaxLogEntries,
  performDataRetentionCleanup,
  startDataRetentionJobs,
  stopDataRetentionJobs,
};
